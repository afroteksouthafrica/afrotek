name: Staging Deploy (Product Service)

on:
  push:
    branches: [ "main" ]
    paths:
      - "services/product-health-proxy/**"
      - ".github/workflows/staging-deploy.yml"
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Optional custom image tag (defaults to short SHA)"
        required: false
        type: string

permissions:
  id-token: write   # for OIDC
  contents: read

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  ECR_REPO: ${{ vars.ECR_REPO }}
  ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
  ECS_SERVICE: ${{ vars.ECS_SERVICE }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Compute image metadata
        id: meta
        shell: bash
        run: |
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            IMAGE_TAG="${GITHUB_SHA::7}"
          fi
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

          # APP_REV for the health header
          APP_REV="gha-${GITHUB_RUN_ID}-$(date +%Y%m%d-%H%M%S)"
          echo "app_rev=$APP_REV" >> $GITHUB_OUTPUT

          # full names
          echo "repo=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}" >> $GITHUB_OUTPUT

      - name: Build image
        working-directory: services/product-health-proxy
        run: |
          docker build \
            --build-arg APP_REV="${{ steps.meta.outputs.app_rev }}" \
            -t "${{ steps.meta.outputs.repo }}:${{ steps.meta.outputs.tag }}" \
            .

      - name: Push image
        run: |
          docker push "${{ steps.meta.outputs.repo }}:${{ steps.meta.outputs.tag }}"

      - name: Resolve digest for the just-pushed tag
        id: digest
        run: |
          DIGEST=$(aws ecr describe-images \
            --repository-name "${ECR_REPO}" \
            --image-ids imageTag="${{ steps.meta.outputs.tag }}" \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Pinned digest: $DIGEST"

      - name: Read current service task definition ARN
        id: td
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "${ECS_CLUSTER}" \
            --services "${ECS_SERVICE}" \
            --query 'services[0].taskDefinition' \
            --output text)
          echo "arn=$TD_ARN" >> $GITHUB_OUTPUT
          echo "Current TD: $TD_ARN"

      - name: Fetch current task definition JSON
        run: |
          aws ecs describe-task-definition \
            --task-definition "${{ steps.td.outputs.arn }}" \
            --query 'taskDefinition' \
            > taskdef.json

      - name: Produce minimal, null-free payload and swap image + APP_REV
        # Requires jq (present on ubuntu-latest)
        run: |
          set -euo pipefail

          REPO="${{ steps.meta.outputs.repo }}"
          DIGEST="${{ steps.digest.outputs.digest }}"
          APP_REV="${{ steps.meta.outputs.app_rev }}"
          PINNED_IMAGE="${REPO}@${DIGEST}"

          # Keep only allowed fields, and update product container
          jq --arg img "$PINNED_IMAGE" \
             --arg apprev "$APP_REV" '
            {
              family,
              taskRoleArn,
              executionRoleArn,
              networkMode,
              containerDefinitions,
              volumes,
              placementConstraints,
              requiresCompatibilities,
              cpu,
              memory,
              runtimePlatform
            }
            # remove nulls
            | with_entries(select(.value != null))
            # make sure containerDefinitions is an array and mutate "product"
            | .containerDefinitions |= (map(
                if .name == "product" then
                  .image = $img
                  | .environment = (
                      (.environment // []) 
                      | map({name, value}) 
                      | (map(select(.name != null)) )
                      | ( [ .[] | select(.name != "APP_REV") ] + [ {name:"APP_REV", value:$apprev} ] )
                    )
                else .
                end
              ))
          ' taskdef.json > register.json

          echo "Prepared register.json:"
          cat register.json

      - name: Register new task definition revision
        id: register
        run: |
          OUT=$(aws ecs register-task-definition --cli-input-json file://register.json)
          echo "$OUT" > register-out.json
          NEW_TD_ARN=$(jq -r '.taskDefinition.taskDefinitionArn' register-out.json)
          echo "arn=$NEW_TD_ARN" >> $GITHUB_OUTPUT
          echo "Registered $NEW_TD_ARN"

      - name: Update service to new task definition
        run: |
          aws ecs update-service \
            --cluster "${ECS_CLUSTER}" \
            --service "${ECS_SERVICE}" \
            --task-definition "${{ steps.register.outputs.arn }}"
          echo "Service updated."

      - name: Wait for steady state
        run: |
          aws ecs wait services-stable \
            --cluster "${ECS_CLUSTER}" \
            --services "${ECS_SERVICE}"
          echo "Service is stable."

      - name: Show running task image + digest (sanity)
        run: |
          TASK_ARN=$(aws ecs list-tasks \
            --cluster "${ECS_CLUSTER}" \
            --service-name "${ECS_SERVICE}" \
            --desired-status RUNNING \
            --query 'taskArns[0]' --output text)
          aws ecs describe-tasks \
            --cluster "${ECS_CLUSTER}" \
            --tasks "$TASK_ARN" \
            --query 'tasks[0].containers[].{name:name,image:image,imageDigest:imageDigest}'

      - name: Curl health via ALB and print headers
        # ALB call is optional; remove if your runner cannot reach it (private)
        shell: bash
        run: |
          set -e
          # If your ALB is public, this works. If private, comment this step.
          echo "---- /product/health headers ----"
          curl -s -D - https://api.afrotek.co.za/product/health -o /dev/null | \
            awk 'BEGIN{IGNORECASE=1}/Strict-Transport-Security:|X-App-Rev:/'
